\documentclass{beamer}

% Must be loaded first
\usepackage{tikz}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=black!5, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{Free All The Things}
\author{Markus Hauck @markus1189}

\newcommand{\recipe}{%
  \begin{itemize}
  \item Define AST
  \item Add \texttt{Inject}
  \item Write Interpreter
  \item Check laws
  \end{itemize}
}

% The presentation content
\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
\frametitle{Free All The Things}
\begin{itemize}
\item well known: free monads
\item maybe known: free applicatives
\item free monoids
\item free <you name it>
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{This Talk}
  \begin{itemize}
  \item explain the technique behind ``Free X''
  \item apply the technique to different examples
  \item takeaway: it's easier than you thought
  \item Source Code: \url{https://github.com/markus1189/free-all-the-things/tree/upnorth}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Let's Get Started}
  \begin{center}
    Ready?
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{What's The Problem}
  \begin{quote}
    A free functor is left adjoint to a forgetful functor
  \end{quote}
  \only<2>{
  \begin{center}
    what's the problem?
  \end{center}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{static-images/smirk.png}
  \end{center}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{What Is Free} A free ``thing'' \textbf{FreeA} on a type(class)
  \textit{A} is a \textit{A} and a function
  \begin{minted}[linenos=false]{scala}
    def inject(x: A): FreeA
  \end{minted}
  such that for any other ``thing'' \textit{B} and a function
  \begin{minted}[linenos=false]{scala}
    val f: A => B
  \end{minted}
  there exists a unique homomorphism \texttt{g} such that
  \begin{minted}[linenos=false]{scala}
    g.compose(inject) === f
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What Is Free}
  \begin{itemize}
  \item still complicated!!!11
  \item a Free X is the \textbf{minimal} structure that
    \textbf{satisfies the laws} of the typeclass X (mine)
  \item rejoice: there is a pretty mechanical recipe
    \recipe{}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why Free}
  \begin{itemize}
  \item nice API using typeclass
  \item use Free X as if it was X
  \item lift your DSL ops using \texttt{inject} (or \texttt{lift})
  \item program reified into datastructure
  \item structure can be analyzed/optimized
  \item one program \textemdash{} many interpretations
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Disclaimer Before We Start}
  \begin{itemize}
  \item deep embeddings / initial encoding / data structure representation
  \item not: finally tagless, optimization, using Free Monads
  \item for some typeclasses, there are different sets of minimal operations (Monad: three!)
  \item fun thing: technique works for every one of them, homework
  \end{itemize}
\end{frame}

\section{Free Monad}\label{sec:free-monad}
\begin{frame}
  \begin{center}
    \Huge
    Freeing The Monad
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Monad Typeclass}
  \begin{itemize}
  \item we use the \texttt{pure} and \texttt{flatMap} version
  \end{itemize}
  \begin{center}
    \inputminted{scala}{snippets/monad-typeclass.scala}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Give Me The Laws}
    \begin{center}
\begin{minted}[autogobble]{scala}
// Left identity
pure(a).flatMap(f) === f(a)

// Right identity
fa.flatMap(pure) === fa

// Associativity
fa.flatMap(f).flatMap(g) ===
  fa.flatMap(a => f(a).flatMap(g))
\end{minted}
    \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Applying The Recipe}
  \begin{center}
    \inputminted{scala}{snippets/monad-typeclass.scala}
  \end{center}
  \begin{itemize}
  \item remember our recipe
    \recipe{}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Monad}
  \begin{center}
    \inputminted{scala}{snippets/free-monad.scala}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Monad}
  \begin{center}
    \inputminted{scala}{snippets/free-instance.scala}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter}
  \inputminted{scala}{snippets/free-interp.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What about the laws?}
  \begin{minted}{scala}
// The associativity law
fa.flatMap(f).flatMap(g) ===
  fa.flatMap(fa, a => f(a).flatMap(g))
  \end{minted}
  \vfill{}
  \inputminted[autogobble]{scala}{snippets/what-about-laws.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What about the laws?}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{static-images/scream.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Laws}
  \begin{itemize}
  \item actually, we don't satisfy them
  \item programmer: after interpretation it's no longer visible
  \item mathematician: that's not the free monad!
  \item tradeoff: during construction vs during interpretation
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Transforming Free Monads: Old Instance}
  \begin{center}
    \inputminted[highlightlines={5-7}, highlightcolor=yellow!40]{scala}{snippets/free-instance.scala}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Transforming Free Monads: Optimized flatMap}
  \only<1>{\inputminted[highlightlines={3}, highlightcolor=yellow!40]{scala}{snippets/opt-free-instance.scala}}
  \only<2>{\inputminted[highlightlines={3, 6}, highlightcolor=yellow!40]{scala}{snippets/opt-free-instance.scala}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Transforming Free Monads: Done}
  \begin{itemize}
  \item what do we learn?
  \item laws are not boring, they allow refactorings and optimization
  \item just by adhering to the law, we made our Free Monad more stack safe
  \end{itemize}
  \begin{minted}{scala}
FlatMap(FlatMap(FlatMap(fa, f), g), ...)
FlatMap(fa, x => FlatMap(f(x), y => FlatMap(g(y), z => ...)))
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{We Freed Monads}
  \begin{itemize}
  \item DSL with monadic expressiveness
  \item context sensitive, branching, loops, fancy control flow
  \item familiarity with monadic style for DSL
  \end{itemize}
\end{frame}

\section{Free Functor}\label{sec:free-functor}
\begin{frame}
  \begin{center}
    \Huge
    Freeing The Functor
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{And Once Again}
  \recipe{}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Functor Typeclass}
  \inputminted{scala}{snippets/functor-typeclass.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Functor Laws}
  \begin{minted}{scala}
// identity law
fa.map(identity) === fa

// composition
fa.map(f).map(g) === fa.map(f.compose(g))
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \only<1>{\inputminted{scala}{snippets/free-functor1.scala}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \begin{itemize}
  \item cool! that was easy
  \item can we get rid of something?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \only<1>{\inputminted[highlightlines={6-7}, highlightcolor=yellow!40]{scala}{snippets/free-functor1.scala}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \inputminted{scala}{snippets/free-functor2.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Clean Code Police}
  \only<1->{%
  \begin{center}
    \includegraphics[width=0.3\textwidth]{static-images/police.png}
  \end{center}
}
\only<2->{%
  \begin{itemize}
  \item only one subclass?
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \inputminted[highlightlines={3-4}, highlightcolor=yellow!40]{scala}{snippets/free-functor2.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \inputminted{scala}{snippets/free-functor3.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Freeing The Functor}
  \inputminted{scala}{snippets/free-functor4.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Free Functor Instance}
  \only<1>{\inputminted[highlightlines={6-8}, highlightcolor=yellow!40]{scala}{snippets/functor-coyoneda.scala}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Free Functor Interpreter}
  \only<1>{\inputminted{scala}{snippets/coyoneda-interp.scala}}
\end{frame}

\begin{frame}
  \frametitle{We Freed Functors}
  \begin{itemize}
  \item DSL with hmm functorial expressiveness?
  \item map fusion! (functor law)
  \item interesting: combine with other structures
  \item boring interpreter, though
  \item still fun!
  \end{itemize}
\end{frame}

\section{Free Monoid}
\label{sec:free-monoid}

\begin{frame}
  \begin{center}
    \Huge
    Freeing The Monoid
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{The Monoid Typeclass}
  \inputminted{scala}{snippets/monoid-typeclass.scala}
\end{frame}

\begin{frame}
  \frametitle{The Free Monoid \textemdash{} First Try}
  \inputminted{scala}{snippets/free-monoid-1.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Laws}
  \begin{minted}{scala}
// left identity
empty |+| x === x

// right identity
x |+| empty === x

// associativity
1 |+| (2 |+| 3) === (1 |+| 2) |+| 3
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{The Laws and Free Monoid}
  \begin{itemize}
  \item let's try to enforce those laws in our structure
  \item goal: correct by construction
  \item arbitrary decision: associate left vs \textbf{right}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Fixing Associativity}
  \inputminted[highlightlines={11,13,7}, highlightcolor=yellow!40]{scala}{snippets/free-monoid-2.scala}
\end{frame}

\begin{frame}
  \frametitle{The Problem With Neutral Elements}
  \begin{itemize}
  \item get rid completely? not possible
  \item limit ourselves to a single element
  \item restrict \texttt{Combine} to have only real values on the left side
  \item goal: minimal canonical structure
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Minimizing Structure \textemdash{} Extract Inject}
  \inputminted[highlightlines={1, 7}, highlightcolor=yellow!40]{scala}{snippets/free-monoid-3.scala}
\end{frame}

\begin{frame}
  \frametitle{Minimizing Structure \textemdash{} Remove Inject}
  \inputminted[highlightlines={5}, highlightcolor=yellow!40]{scala}{snippets/free-monoid-4.scala}
\end{frame}

\begin{frame}
  \frametitle{The Monoid Instance}
  \inputminted{scala}{snippets/free-monoid-instance.scala}
\end{frame}

\begin{frame}
  \frametitle{Minimizing Structure \textemdash{} Looks Familiar?}
  \inputminted{scala}{snippets/free-monoid-4.scala}
\end{frame}

\begin{frame}
  \frametitle{Minimizing Structure \textemdash{} List}
  \inputminted{scala}{snippets/free-monoid-5.scala}
\end{frame}

\begin{frame}
  \frametitle{We Freed Monoids}
  \begin{itemize}
  \item DSL for combining things
  \item works beautifully with folds
  \item interpretation can be in parallel (associativity)
  \end{itemize}
\end{frame}

\section{Free Boolean Algebra}\label{sec:free-boolean-algebra}

\begin{frame}
  \frametitle{Now That We Can Free Anything}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{static-images/thinking.png}
    \vfill
    {\Huge What should we free?}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Credit Where It's Due}
  \begin{itemize}
  \item Once upon a time:
    https://engineering.wingify.com/posts/Free-objects/
  \item use \textbf{free boolean algebra} to define DSL for event
    predicates
  \item credits to Chris Stucchio (@stucchio)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Let's Free A Boolean Algebra}
  \recipe{}
\end{frame}

\begin{frame}
  \frametitle{Boolean Algebras}
  \inputminted{scala}{snippets/boolean-algebra.scala}
\end{frame}

\begin{frame}
  \frametitle{Free Boolean Algebra}
  \inputminted{scala}{snippets/free-bool.scala}
\end{frame}

\begin{frame}
  \frametitle{Free Boolean Algebra}
  \only<1>{\inputminted[highlightlines={1-2}, highlightcolor=yellow!40]{scala}{snippets/free-bool-interp.scala}}
  \only<2>{\inputminted[highlightlines={4,5}, highlightcolor=yellow!40]{scala}{snippets/free-bool-interp.scala}}
  \only<3>{\inputminted[highlightlines={6}, highlightcolor=yellow!40]{scala}{snippets/free-bool-interp.scala}}
  \only<4>{\inputminted[highlightlines={7}, highlightcolor=yellow!40]{scala}{snippets/free-bool-interp.scala}}
  \only<5>{\inputminted[highlightlines={9,11}, highlightcolor=yellow!40]{scala}{snippets/free-bool-interp.scala}}
\end{frame}

\begin{frame}
  \frametitle{Using Free Bool}
  \begin{itemize}
  \item that was simple (though boilerplate-y)
  \item what can we do with our new discovered structure
  \item reminder: boolean operators
    \begin{itemize}
    \item true, false
    \item and, or
    \item xor, implies, nand, nor, nxor
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free Bool Example: Search}
  \inputminted{scala}{snippets/search-predicate.scala}
\end{frame}

\begin{frame}
  \frametitle{Free Bool Example: Search}
  \begin{itemize}
  \item after sneaking in syntactic sugar behind the scenes:
  \end{itemize}
  \inputminted{scala}{snippets/example-search-predicate.scala}
\end{frame}

\begin{frame}
  \frametitle{The Site Type}
  \inputminted{scala}{snippets/site-type.scala}
  \begin{itemize}
  \item all predicates are run against a collection of these
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free Bool Example: Search}
  \only<1>{\inputminted[highlightlines={4}, highlightcolor=yellow!40]{scala}{snippets/eval-search-predicate.scala}}
  \only<2>{\inputminted[highlightlines={5}, highlightcolor=yellow!40]{scala}{snippets/eval-search-predicate.scala}}
  \only<3>{\inputminted[highlightlines={6}, highlightcolor=yellow!40]{scala}{snippets/eval-search-predicate.scala}}
  \only<4>{\inputminted[highlightlines={7}, highlightcolor=yellow!40]{scala}{snippets/eval-search-predicate.scala}}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
    \Huge
    Demo Time
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{But Wait There's More}
  \begin{itemize}
  \item short circuiting and other optimization
  \item what if you don't have all the information?
    \begin{itemize}
    \item partially evaluate predicates
    \item if evaluates successfully, done
    \item else, send it on
    \end{itemize}
  \item core language vs extension
    \begin{itemize}
    \item Chris also demonstrates extension
    \item translate a rich language to base instructions
    \item with all the advantages
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Optimizing Boolean Algebras}
  \inputminted{scala}{snippets/optimizing-boolean-algebras.scala}
\end{frame}

\begin{frame}
  \frametitle{Partial Evaluation}
  \begin{itemize}
  \item idea: you might have only partial information
  \item evaluate as much as possible
  \item optimal: we can already reduce without needing more information
  \item otherwise: send it on (JSON, Protobuf, \ldots{})
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Partial Evaluation}
  \inputminted{scala}{snippets/partial-evaluator.scala}
\end{frame}

\begin{frame}
  \frametitle{Partial Evaluation}
  \inputminted{scala}{snippets/partially.scala}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
    \Huge
    Demo Time
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{We Freed Boolean Algebras}
  \begin{itemize}
  \item good example of underused free structure
  \item partial evaluation
  \item serialize the AST (JSON, Protobuf, Avro, \ldots{})
  \item exercise: minimize AST representation
  \end{itemize}
\end{frame}

\section{Conclusion}\label{sec:conclusion}

\begin{frame}
  \frametitle{Resources}
  \begin{itemize}
  \item Free Boolean Algebra by Chris Stucchio \url{https://engineering.wingify.com/posts/Free-objects/}
  \item Source Code: \url{https://github.com/markus1189/free-all-the-things/tree/upnorth}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \Huge
    Go And Free All The Things!
  \end{center}
  \begin{center}
    Markus Hauck (@markus1189)
  \end{center}
\end{frame}

\begin{frame}
  \tableofcontents{}
\end{frame}

\appendix{}

\section*{Bonus}\label{sec:bonus}

\section{Free Applicative}\label{sec:free-applicative}
\begin{frame}
  \begin{center}
    \Huge
    Freeing The Applicative
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Freeing The Applicative}
  \begin{itemize}
  \item free monads are great, but also limited
  \item we can't analyze the programs
  \item how about a smaller abstraction?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Recall}
  \recipe{}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Applicative Typeclass}
  \inputminted{scala}{snippets/applicative-typeclass.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{AST for FreeApplicative}
    \inputminted{scala}{snippets/free-applicative.scala}
  \begin{minted}[autogobble]{scala}
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Laws}
\begin{minted}[autogobble]{scala}
// identity
Ap(Pure(identity), v) === v

// composition
Ap(Ap(Ap(Pure(_.compose), u), v), w) ===
  Ap(u, Ap(v, w))

// homomorphism
Ap(Pure(f), Pure(x)) === Pure(f(x))

// interchange
Ap(u, Pure(y)) === Ap(Pure(_(y)), u)
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Don't Forget The Laws}
  \only<1>{\inputminted[highlightlines={5, 7}, highlightcolor=yellow!40]{scala}{snippets/opt-free-ap-instance.scala}}
\end{frame}

\begin{frame}
  \frametitle{Running FreeApplicatives}
  \inputminted{scala}{snippets/freeap-interp.scala}
\end{frame}

\begin{frame}
  \frametitle{We Freed Applicatives}
  \begin{itemize}
  \item DSL with applicative expressiveness
  \item context insensitive
  \item pure computation over effectful arguments
  \item more freedom during interpretation
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Going Deeper}
  \begin{itemize}
  \item try to encode one of the normal forms for boolean algebras
  \item try to remove \texttt{Inject} cases from Monad and Applicative
  \item free Magmas
  \item define free X using alternative minimal set of ops of the typeclass
  \end{itemize}
\end{frame}

\end{document}
